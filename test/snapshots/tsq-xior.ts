/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//   Generated using Swaggie (https://github.com/yhnavein/swaggie)
//   Please avoid doing any manual changes in this file
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
// deno-lint-ignore-file

import xior, { type XiorResponse, type XiorRequestConfig, encodeParams } from "xior";
import { QueryClient, type UseQueryOptions, useQuery } from '@tanstack/react-query';

export const queryClient = new QueryClient();

export const http = xior.create({
  baseURL: '',
  paramsSerializer: (params) =>
    encodeParams(params, true, null, {
      allowDots: true,
      arrayFormat: 'repeat',
    }),
});

export const petClient = {
   /**
  * Add a new pet to the store
  * @param body
  */
  addPet(body: Pet ,
    $config?: XiorRequestConfig
  ): Promise<XiorResponse<Pet>> {
    const url = `/pet`;

    return http.request<Pet>({
      url: url,
      method: 'POST',
      data: body,
      ...$config,
    });
  },

 /**
  * Deletes a pet
  * @param apiKey (optional) (API name: api_key)
  * @param petId - ID of the pet
  */
  deletePet(apiKey: string | null | undefined,
    petId: number ,
    $config?: XiorRequestConfig
  ): Promise<XiorResponse<unknown>> {
    const url = `/pet/${encodeURIComponent(`${petId}`)}`;

    return http.request<unknown>({
      url: url,
      method: 'DELETE',
      headers: {
        'api_key': apiKey,
      },
      ...$config,
    });
  },

 /**
  * Finds Pets by status
  * Multiple status values can be provided with comma separated strings
  * @param status (optional) - Status values that need to be considered for filter
  */
  findPetsByStatus(status?: ("available" | "pending" | "sold") | null,
    $config?: XiorRequestConfig
  ): Promise<XiorResponse<Pet[]>> {
    const url = `/pet/findByStatus`;

    return http.request<Pet[]>({
      url: url,
      method: 'GET',
      params: {
        'status': status,
      },
      ...$config,
    });
  },

 /**
  * Finds Pets by tags
  * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
  * @deprecated
  * @param tags (optional) - Tags to filter by
  */
  findPetsByTags(tags?: string[] | null,
    $config?: XiorRequestConfig
  ): Promise<XiorResponse<Pet[]>> {
    const url = `/pet/findByTags`;

    return http.request<Pet[]>({
      url: url,
      method: 'GET',
      params: {
        'tags': tags,
      },
      ...$config,
    });
  },

 /**
  * Find pet by ID
  * Returns a single pet
  * @param petId - ID of the pet
  */
  getPetById(petId: number ,
    $config?: XiorRequestConfig
  ): Promise<XiorResponse<Pet>> {
    const url = `/pet/${encodeURIComponent(`${petId}`)}`;

    return http.request<Pet>({
      url: url,
      method: 'GET',
      ...$config,
    });
  },

 /**
  * Update an existing pet by Id
  * @param body
  */
  updatePet(body: Pet ,
    $config?: XiorRequestConfig
  ): Promise<XiorResponse<Pet>> {
    const url = `/pet`;

    return http.request<Pet>({
      url: url,
      method: 'PUT',
      data: new URLSearchParams(body as any),
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      ...$config,
    });
  },

 /**
  * Updates a pet in the store with form data
  * @param petId - ID of the pet
  * @param name (optional) - Name of pet that needs to be updated
  * @param status (optional) - Status of pet that needs to be updated
  */
  updatePetWithForm(petId: number ,
    name?: string | null,
    status?: string | null,
    $config?: XiorRequestConfig
  ): Promise<XiorResponse<unknown>> {
    const url = `/pet/${encodeURIComponent(`${petId}`)}`;

    return http.request<unknown>({
      url: url,
      method: 'POST',
      params: {
        'name': name,
        'status': status,
      },
      ...$config,
    });
  },

 /**
  * uploads an image
  * @param body (optional)
  * @param petId - ID of the pet
  * @param additionalMetadata (optional) - Additional Metadata
  */
  uploadFile(body: File | null | undefined,
    petId: number ,
    additionalMetadata?: string | null,
    $config?: XiorRequestConfig
  ): Promise<XiorResponse<File>> {
    const url = `/pet/${encodeURIComponent(`${petId}`)}/uploadImage`;

    return http.request<File>({
      url: url,
      method: 'POST',
      data: body,
      params: {
        'additionalMetadata': additionalMetadata,
      },
      ...$config,
    });
  },

};


   /**
  * Finds Pets by status
  * Multiple status values can be provided with comma separated strings
  * @param status (optional) - Status values that need to be considered for filter
  * @param $config (optional) Additional configuration for TanStack Query
  * @param $httpConfig (optional) Additional configuration for xior request (actually executes the request)
 */
export function usepetfindPetsByStatus<TData = Pet[], TError = Error>(  status?: ("available" | "pending" | "sold") | null,
    $config?: Omit<
  UseQueryOptions<Pet[], TError, TData>,
  'queryKey' | 'queryFn'
>,
    $httpConfig?: XiorRequestConfig
  ) {
  return useQuery<Pet[], TError, TData>({
    queryKey: ['pet', 'petfindPetsByStatus', status, ],
    queryFn: () => petClient.findPetsByStatus(status, $httpConfig).then(res => res.data),
    ...$config
  });
}
usepetfindPetsByStatus.queryKeys = ['pet', 'petfindPetsByStatus'];

   /**
  * Finds Pets by tags
  * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
  * @deprecated
  * @param tags (optional) - Tags to filter by
  * @param $config (optional) Additional configuration for TanStack Query
  * @param $httpConfig (optional) Additional configuration for xior request (actually executes the request)
 */
export function usepetfindPetsByTags<TData = Pet[], TError = Error>(  tags?: string[] | null,
    $config?: Omit<
  UseQueryOptions<Pet[], TError, TData>,
  'queryKey' | 'queryFn'
>,
    $httpConfig?: XiorRequestConfig
  ) {
  return useQuery<Pet[], TError, TData>({
    queryKey: ['pet', 'petfindPetsByTags', tags, ],
    queryFn: () => petClient.findPetsByTags(tags, $httpConfig).then(res => res.data),
    ...$config
  });
}
usepetfindPetsByTags.queryKeys = ['pet', 'petfindPetsByTags'];

   /**
  * Find pet by ID
  * Returns a single pet
  * @param petId - ID of the pet
  * @param $config (optional) Additional configuration for TanStack Query
  * @param $httpConfig (optional) Additional configuration for xior request (actually executes the request)
 */
export function usepetPetById<TData = Pet, TError = Error>(  petId: number ,
    $config?: Omit<
  UseQueryOptions<Pet, TError, TData>,
  'queryKey' | 'queryFn'
>,
    $httpConfig?: XiorRequestConfig
  ) {
  return useQuery<Pet, TError, TData>({
    queryKey: ['pet', 'petPetById', petId, ],
    queryFn: () => petClient.getPetById(petId, $httpConfig).then(res => res.data),
    ...$config
  });
}
usepetPetById.queryKeys = ['pet', 'petPetById'];

  export const storeClient = {
   /**
  * Delete purchase order by ID
  * For valid response try integer IDs with value &lt; 1000. Anything above 1000 or nonintegers will generate API errors
  * @param orderId - ID of the order that needs to be deleted
  */
  deleteOrder(orderId: number ,
    $config?: XiorRequestConfig
  ): Promise<XiorResponse<unknown>> {
    const url = `/store/order/${encodeURIComponent(`${orderId}`)}`;

    return http.request<unknown>({
      url: url,
      method: 'DELETE',
      ...$config,
    });
  },

 /**
  * Returns pet inventories by status
  * Returns a map of status codes to quantities
  */
  getInventory($config?: XiorRequestConfig
  ): Promise<XiorResponse<{ [key: string]: number }>> {
    const url = `/store/inventory`;

    return http.request<{ [key: string]: number }>({
      url: url,
      method: 'GET',
      ...$config,
    });
  },

 /**
  * Find purchase order by ID
  * For valid response try integer IDs with value &le; 5 or &gt; 10. Other values will generate exceptions.
  * @param orderId - ID of order that needs to be fetched
  */
  getOrderById(orderId: number ,
    $config?: XiorRequestConfig
  ): Promise<XiorResponse<Order>> {
    const url = `/store/order/${encodeURIComponent(`${orderId}`)}`;

    return http.request<Order>({
      url: url,
      method: 'GET',
      ...$config,
    });
  },

 /**
  * Place an order for a pet
  * Place a new order in the store
  * @param body (optional)
  */
  placeOrder(body?: Order | null,
    $config?: XiorRequestConfig
  ): Promise<XiorResponse<Order>> {
    const url = `/store/order`;

    return http.request<Order>({
      url: url,
      method: 'POST',
      data: body,
      ...$config,
    });
  },

};


   /**
  * Returns pet inventories by status
  * Returns a map of status codes to quantities
  * @param $config (optional) Additional configuration for TanStack Query
  * @param $httpConfig (optional) Additional configuration for xior request (actually executes the request)
 */
export function usestoreInventory<TData = { [key: string]: number }, TError = Error>($config?: Omit<
  UseQueryOptions<{ [key: string]: number }, TError, TData>,
  'queryKey' | 'queryFn'
>,
    $httpConfig?: XiorRequestConfig
  ) {
  return useQuery<{ [key: string]: number }, TError, TData>({
    queryKey: ['store', 'storeInventory', ],
    queryFn: () => storeClient.getInventory($httpConfig).then(res => res.data),
    ...$config
  });
}
usestoreInventory.queryKeys = ['store', 'storeInventory'];

   /**
  * Find purchase order by ID
  * For valid response try integer IDs with value &le; 5 or &gt; 10. Other values will generate exceptions.
  * @param orderId - ID of order that needs to be fetched
  * @param $config (optional) Additional configuration for TanStack Query
  * @param $httpConfig (optional) Additional configuration for xior request (actually executes the request)
 */
export function usestoreOrderById<TData = Order, TError = Error>(  orderId: number ,
    $config?: Omit<
  UseQueryOptions<Order, TError, TData>,
  'queryKey' | 'queryFn'
>,
    $httpConfig?: XiorRequestConfig
  ) {
  return useQuery<Order, TError, TData>({
    queryKey: ['store', 'storeOrderById', orderId, ],
    queryFn: () => storeClient.getOrderById(orderId, $httpConfig).then(res => res.data),
    ...$config
  });
}
usestoreOrderById.queryKeys = ['store', 'storeOrderById'];

  export const userClient = {
   /**
  * Create user
  * This can only be done by the logged in user.
  * @param body (optional)
  */
  createUser(body?: User | null,
    $config?: XiorRequestConfig
  ): Promise<XiorResponse<User>> {
    const url = `/user`;

    return http.request<User>({
      url: url,
      method: 'POST',
      data: body,
      ...$config,
    });
  },

 /**
  * Creates list of users with given input array
  * @param body (optional)
  */
  createUsersWithListInput(body?: User[] | null,
    $config?: XiorRequestConfig
  ): Promise<XiorResponse<User>> {
    const url = `/user/createWithList`;

    return http.request<User>({
      url: url,
      method: 'POST',
      data: body,
      ...$config,
    });
  },

 /**
  * Delete user
  * This can only be done by the logged in user.
  * @param username - The name that needs to be deleted
  */
  deleteUser(username: string ,
    $config?: XiorRequestConfig
  ): Promise<XiorResponse<unknown>> {
    const url = `/user/${encodeURIComponent(`${username}`)}`;

    return http.request<unknown>({
      url: url,
      method: 'DELETE',
      ...$config,
    });
  },

 /**
  * Get user by user name
  * @param username - The name that needs to be fetched. Use user1 for testing.
  */
  getUserByName(username: string ,
    $config?: XiorRequestConfig
  ): Promise<XiorResponse<User>> {
    const url = `/user/${encodeURIComponent(`${username}`)}`;

    return http.request<User>({
      url: url,
      method: 'GET',
      ...$config,
    });
  },

 /**
  * Logs user into the system
  * @param username (optional) - The user name for login
  * @param password (optional) - The password for login in clear text
  */
  loginUser(username?: string | null,
    password?: string | null,
    $config?: XiorRequestConfig
  ): Promise<XiorResponse<string>> {
    const url = `/user/login`;

    return http.request<string>({
      url: url,
      method: 'GET',
      params: {
        'username': username,
        'password': password,
      },
      ...$config,
    });
  },

/** Logs out current logged in user session */
  logoutUser($config?: XiorRequestConfig
  ): Promise<XiorResponse<unknown>> {
    const url = `/user/logout`;

    return http.request<unknown>({
      url: url,
      method: 'GET',
      ...$config,
    });
  },

 /**
  * Update user
  * This can only be done by the logged in user.
  * @param body (optional)
  * @param username - name that needs to be updated
  */
  updateUser(body: FormData | null | undefined,
    username: string ,
    $config?: XiorRequestConfig
  ): Promise<XiorResponse<unknown>> {
    const url = `/user/${encodeURIComponent(`${username}`)}`;

    return http.request<unknown>({
      url: url,
      method: 'PUT',
      data: body,
      ...$config,
    });
  },

};


   /**
  * Get user by user name
  * @param username - The name that needs to be fetched. Use user1 for testing.
  * @param $config (optional) Additional configuration for TanStack Query
  * @param $httpConfig (optional) Additional configuration for xior request (actually executes the request)
 */
export function useuserUserByName<TData = User, TError = Error>(  username: string ,
    $config?: Omit<
  UseQueryOptions<User, TError, TData>,
  'queryKey' | 'queryFn'
>,
    $httpConfig?: XiorRequestConfig
  ) {
  return useQuery<User, TError, TData>({
    queryKey: ['user', 'userUserByName', username, ],
    queryFn: () => userClient.getUserByName(username, $httpConfig).then(res => res.data),
    ...$config
  });
}
useuserUserByName.queryKeys = ['user', 'userUserByName'];

   /**
  * Logs user into the system
  * @param username (optional) - The user name for login
  * @param password (optional) - The password for login in clear text
  * @param $config (optional) Additional configuration for TanStack Query
  * @param $httpConfig (optional) Additional configuration for xior request (actually executes the request)
 */
export function useuserloginUser<TData = string, TError = Error>(  username?: string | null,
      password?: string | null,
    $config?: Omit<
  UseQueryOptions<string, TError, TData>,
  'queryKey' | 'queryFn'
>,
    $httpConfig?: XiorRequestConfig
  ) {
  return useQuery<string, TError, TData>({
    queryKey: ['user', 'userloginUser', username, password, ],
    queryFn: () => userClient.loginUser(username, password, $httpConfig).then(res => res.data),
    ...$config
  });
}
useuserloginUser.queryKeys = ['user', 'userloginUser'];

  /** Logs out current logged in user session
  * @param $config (optional) Additional configuration for TanStack Query
  * @param $httpConfig (optional) Additional configuration for xior request (actually executes the request)
 */
export function useuserlogoutUser<TData = unknown, TError = Error>($config?: Omit<
  UseQueryOptions<unknown, TError, TData>,
  'queryKey' | 'queryFn'
>,
    $httpConfig?: XiorRequestConfig
  ) {
  return useQuery<unknown, TError, TData>({
    queryKey: ['user', 'userlogoutUser', ],
    queryFn: () => userClient.logoutUser($httpConfig).then(res => res.data),
    ...$config
  });
}
useuserlogoutUser.queryKeys = ['user', 'userlogoutUser'];

  export interface Order {
  id?: number;
  petId?: number;
  quantity?: number;
  shipDate?: Date;
/** Order Status */
  status?: ("placed" | "approved" | "delivered");
  complete?: boolean;}

export interface Category {
  id?: number;
  name?: string;}

export interface User {
  id?: number;
  username?: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  password?: string;
  phone?: string;
/** User Status */
  userStatus?: number;}

export interface Tag {
  id?: number;
  name?: string;}

export interface Pet {
  id?: number;
  name: string;
  category?: Category;
  photoUrls: string[];
  tags?: Tag[];
/** pet status in the store */
  status?: ("available" | "pending" | "sold");}
