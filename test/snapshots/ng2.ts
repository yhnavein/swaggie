/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//   Generated using Swaggie (https://github.com/yhnavein/swaggie)
//   Please avoid doing any manual changes in this file
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
// deno-lint-ignore-file

import type { Observable } from "rxjs";
import { Injectable, Inject, Optional, InjectionToken } from "@angular/core";
import { HttpClient } from "@angular/common/http";

export const API_BASE_URL = new InjectionToken<string>("API_BASE_URL");

abstract class BaseService {
  private httpClient: HttpClient;
  private baseUrl: string;

  constructor(
    @Inject(HttpClient) httpClient: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.httpClient = httpClient;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  protected $get<T>(url: string, options?: any): Observable<T> {
    return this.httpClient
      .get<T>(this.baseUrl + url, options)
      .pipe((response: any) => response);
  }

  protected $getAll<T>(url: string, options?: any): Observable<T[]> {
    return this.httpClient
      .get<T[]>(this.baseUrl + url, options)
      .pipe((response: any) => response);
  }

  protected $delete<T>(url: string, options?: any): Observable<T> {
    return this.httpClient
      .delete(this.baseUrl + url, options)
      .pipe((response: any) => response);
  }

  protected $post(url: string, data: any, options?: any): Observable<any> {
    return this.httpClient
      .post(this.baseUrl + url, data, options)
      .pipe((response: any) => response);
  }

  protected $patch<T>(url: string, data: any, options?: any): Observable<T> {
    return this.httpClient
      .patch(this.baseUrl + url, data, options)
      .pipe((response: any) => response);
  }

  protected $put(url: string, data: any, options?: any): Observable<any> {
    return this.httpClient
      .put(this.baseUrl + url, data, options)
      .pipe((response: any) => response);
  }
}

function paramsSerializer(params: any) {
  return encodeParams(params, null, {
    allowDots: true,
    arrayFormat: 'repeat',
  });
}

@Injectable({
  providedIn: 'root'
})
export class petService extends BaseService {
  constructor(
    @Inject(HttpClient) httpClient: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    super(httpClient, baseUrl);
  }

   /**
  * Add a new pet to the store
  * @param body
  */
  addPet(
    body: Pet ,
    config?: any
  ): Observable<Pet> {
    const url = `/pet?`;

    return this.$post(
      url,
      body,
      config
    );
  }

 /**
  * Deletes a pet
  * @param apiKey (optional) (API name: api_key)
  * @param petId - ID of the pet
  */
  deletePet(
    apiKey: string | null | undefined,
    petId: number ,
    config?: any
  ): Observable<unknown> {
    const url = `/pet/${encodeURIComponent(`${petId}`)}?`;

    return this.$delete(
      url,
      config
    );
  }

 /**
  * Finds Pets by status
  * Multiple status values can be provided with comma separated strings
  * @param status (optional) - Status values that need to be considered for filter
  */
  findPetsByStatus(
    status?: ("available" | "pending" | "sold") | null,
    config?: any
  ): Observable<Pet[]> {
    const url = `/pet/findByStatus?${paramsSerializer({'status': status,
      })}`;

    return this.$get(
      url,
      config
    );
  }

 /**
  * Finds Pets by tags
  * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
  * @deprecated
  * @param tags (optional) - Tags to filter by
  */
  findPetsByTags(
    tags?: string[] | null,
    config?: any
  ): Observable<Pet[]> {
    const url = `/pet/findByTags?${paramsSerializer({'tags': tags,
      })}`;

    return this.$get(
      url,
      config
    );
  }

 /**
  * Find pet by ID
  * Returns a single pet
  * @param petId - ID of the pet
  */
  getPetById(
    petId: number ,
    config?: any
  ): Observable<Pet> {
    const url = `/pet/${encodeURIComponent(`${petId}`)}?`;

    return this.$get(
      url,
      config
    );
  }

 /**
  * Update an existing pet by Id
  * @param body
  */
  updatePet(
    body: Pet ,
    config?: any
  ): Observable<Pet> {
    const url = `/pet?`;

    return this.$put(
      url,
      new URLSearchParams(body as any),
      config
    );
  }

 /**
  * Updates a pet in the store with form data
  * @param petId - ID of the pet
  * @param name (optional) - Name of pet that needs to be updated
  * @param status (optional) - Status of pet that needs to be updated
  */
  updatePetWithForm(
    petId: number ,
    name?: string | null,
    status?: string | null,
    config?: any
  ): Observable<unknown> {
    const url = `/pet/${encodeURIComponent(`${petId}`)}?${paramsSerializer({'name': name,
      'status': status,
      })}`;

    return this.$post(
      url,
      null,
      config
    );
  }

 /**
  * uploads an image
  * @param body (optional)
  * @param petId - ID of the pet
  * @param additionalMetadata (optional) - Additional Metadata
  */
  uploadFile(
    body: File | null | undefined,
    petId: number ,
    additionalMetadata?: string | null,
    config?: any
  ): Observable<File> {
    const url = `/pet/${encodeURIComponent(`${petId}`)}/uploadImage?${paramsSerializer({'additionalMetadata': additionalMetadata,
      })}`;

    return this.$post(
      url,
      body,
      config
    );
  }

}

@Injectable({
  providedIn: 'root'
})
export class storeService extends BaseService {
  constructor(
    @Inject(HttpClient) httpClient: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    super(httpClient, baseUrl);
  }

   /**
  * Delete purchase order by ID
  * For valid response try integer IDs with value &lt; 1000. Anything above 1000 or nonintegers will generate API errors
  * @param orderId - ID of the order that needs to be deleted
  */
  deleteOrder(
    orderId: number ,
    config?: any
  ): Observable<unknown> {
    const url = `/store/order/${encodeURIComponent(`${orderId}`)}?`;

    return this.$delete(
      url,
      config
    );
  }

 /**
  * Returns pet inventories by status
  * Returns a map of status codes to quantities
  */
  getInventory(
    config?: any
  ): Observable<{ [key: string]: number }> {
    const url = `/store/inventory?`;

    return this.$get(
      url,
      config
    );
  }

 /**
  * Find purchase order by ID
  * For valid response try integer IDs with value &le; 5 or &gt; 10. Other values will generate exceptions.
  * @param orderId - ID of order that needs to be fetched
  */
  getOrderById(
    orderId: number ,
    config?: any
  ): Observable<Order> {
    const url = `/store/order/${encodeURIComponent(`${orderId}`)}?`;

    return this.$get(
      url,
      config
    );
  }

 /**
  * Place an order for a pet
  * Place a new order in the store
  * @param body (optional)
  */
  placeOrder(
    body?: Order | null,
    config?: any
  ): Observable<Order> {
    const url = `/store/order?`;

    return this.$post(
      url,
      body,
      config
    );
  }

}

@Injectable({
  providedIn: 'root'
})
export class userService extends BaseService {
  constructor(
    @Inject(HttpClient) httpClient: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    super(httpClient, baseUrl);
  }

   /**
  * Create user
  * This can only be done by the logged in user.
  * @param body (optional)
  */
  createUser(
    body?: User | null,
    config?: any
  ): Observable<User> {
    const url = `/user?`;

    return this.$post(
      url,
      body,
      config
    );
  }

 /**
  * Creates list of users with given input array
  * @param body (optional)
  */
  createUsersWithListInput(
    body?: User[] | null,
    config?: any
  ): Observable<User> {
    const url = `/user/createWithList?`;

    return this.$post(
      url,
      body,
      config
    );
  }

 /**
  * Delete user
  * This can only be done by the logged in user.
  * @param username - The name that needs to be deleted
  */
  deleteUser(
    username: string ,
    config?: any
  ): Observable<unknown> {
    const url = `/user/${encodeURIComponent(`${username}`)}?`;

    return this.$delete(
      url,
      config
    );
  }

 /**
  * Get user by user name
  * @param username - The name that needs to be fetched. Use user1 for testing.
  */
  getUserByName(
    username: string ,
    config?: any
  ): Observable<User> {
    const url = `/user/${encodeURIComponent(`${username}`)}?`;

    return this.$get(
      url,
      config
    );
  }

 /**
  * Logs user into the system
  * @param username (optional) - The user name for login
  * @param password (optional) - The password for login in clear text
  */
  loginUser(
    username?: string | null,
    password?: string | null,
    config?: any
  ): Observable<string> {
    const url = `/user/login?${paramsSerializer({'username': username,
      'password': password,
      })}`;

    return this.$get(
      url,
      config
    );
  }

/** Logs out current logged in user session */
  logoutUser(
    config?: any
  ): Observable<unknown> {
    const url = `/user/logout?`;

    return this.$get(
      url,
      config
    );
  }

 /**
  * Update user
  * This can only be done by the logged in user.
  * @param body (optional)
  * @param username - name that needs to be updated
  */
  updateUser(
    body: FormData | null | undefined,
    username: string ,
    config?: any
  ): Observable<unknown> {
    const url = `/user/${encodeURIComponent(`${username}`)}?`;

    return this.$put(
      url,
      body,
      config
    );
  }

}


/**
 * Serializes a params object into a query string that is compatible with different REST APIs.
 * Implementation from: https://github.com/suhaotian/xior/blob/main/src/utils.ts
 * Kudos to @suhaotian for the original implementation
 */
function encodeParams<T = any>(
  params: T,
  parentKey: string | null = null,
  options?: {
    allowDots?: boolean;
    serializeDate?: (value: Date) => string;
    arrayFormat?: 'indices' | 'repeat' | 'brackets';
  }
): string {
  if (params === undefined || params === null) return '';
  const encodedParams: string[] = [];
  const paramsIsArray = Array.isArray(params);
  const { arrayFormat, allowDots, serializeDate } = options || {};

  const getKey = (key: string) => {
    if (allowDots && !paramsIsArray) return `.${key}`;
    if (paramsIsArray) {
      if (arrayFormat === 'brackets') {
        return '[]';
      }
      if (arrayFormat === 'repeat') {
        return '';
      }
    }
    return `[${key}]`;
  };

  for (const key in params) {
    if (Object.prototype.hasOwnProperty.call(params, key)) {
      let value = (params as any)[key];
      if (value !== undefined) {
        const encodedKey = parentKey ? `${parentKey}${getKey(key)}` : (key as string);

        // biome-ignore lint/suspicious/noGlobalIsNan: <explanation>
        if (!isNaN(value) && value instanceof Date) {
          value = serializeDate ? serializeDate(value) : value.toISOString();
        }
        if (typeof value === 'object') {
          // If the value is an object or array, recursively encode its contents
          const result = encodeParams(value, encodedKey, options);
          if (result !== '') encodedParams.push(result);
        } else {
          // Otherwise, encode the key-value pair
          encodedParams.push(`${encodeURIComponent(encodedKey)}=${encodeURIComponent(value)}`);
        }
      }
    }
  }

  return encodedParams.join('&');
}

export interface Order {
  id?: number;
  petId?: number;
  quantity?: number;
  shipDate?: Date;
/** Order Status */
  status?: ("placed" | "approved" | "delivered");
  complete?: boolean;}

export interface Category {
  id?: number;
  name?: string;}

export interface User {
  id?: number;
  username?: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  password?: string;
  phone?: string;
/** User Status */
  userStatus?: number;}

export interface Tag {
  id?: number;
  name?: string;}

export interface Pet {
  id?: number;
  name: string;
  category?: Category;
  photoUrls: string[];
  tags?: Tag[];
/** pet status in the store */
  status?: ("available" | "pending" | "sold");}
